use byteorder::{ByteOrder, BigEndian};

pub struct Triplet {
    pub extended_length: u8,
    pub tag: u8,
    pub length: usize,
    pub value: Vec<u8>,
}

impl Triplet {

    fn extract_length(length: u8, bytes: &[u8]) -> usize {
        if length < 0x81 {
            length as usize
        }
        else if length < 0x82 {
            bytes[0] as usize
        }
        else if length < 0x83 {
            BigEndian::read_u16(&bytes) as usize
        }
        else if length < 0x84 {
            BigEndian::read_u24(&bytes) as usize
        }
        else if length < 0x85 {
            BigEndian::read_u32(&bytes) as usize
        }
        else {
            panic!("ASN.1 length too long {}", length);
        }
    }

    pub fn len(&self) -> usize {
        2 + self.extended_length as usize + self.value.len()
    }

    pub fn byte_len(&self) -> usize {
        self.extended_length as usize + 2
    }

    pub fn from_bytes(bytes: &[u8]) -> Triplet {
        let tag = bytes[0];
        
        let extended_length: u8;
        if bytes[1] > 0x80 {
            extended_length = bytes[1] & 0x0F; // 0x8X where X is the length
        }
        else {
            extended_length = 0u8;
        }
        
        let length = Self::extract_length(bytes[1], &bytes[2..6]);
        let start_value = 2 + extended_length as usize;
        let value = bytes[start_value..start_value+length].to_vec();
        Triplet { extended_length, tag, length, value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_bytes() {
        let bytes = vec![0x80, 0x04, 0x34, 0x30, 0x30, 0x30];
        let result = Triplet::from_bytes(&bytes);
        assert_eq!(result.tag, 0x80);
        assert_eq!(result.length, 4);
        assert_eq!(result.value, vec![0x34, 0x30, 0x30, 0x30]);
        assert_eq!(result.len(), 6);
        assert_eq!(result.extended_length, 0);
    }

     #[test]
    fn test_from_bytes_extended_length() {
        let bytes = vec![  // seq_asdu field and extended length with 2 asdu
            0xa2, 0x81, 0xae,
            0x30, 0x55, 0x80, 0x4, 0x34, 0x30, 0x30, 0x31, 0x82, 0x2, 0x12, 0xbf, 0x83, 0x4, 0x0, 0x0, 0x0, 0x1, 0x85, 0x1, 0x2, 0x87, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x30, 0x55, 0x80, 0x4, 0x34, 0x30, 0x30, 0x31, 0x82, 0x2, 0x0, 0x0, 0x83, 0x4, 0x0, 0x0, 0x0, 0x1, 0x85, 0x1, 0x2, 0x87, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        ];
        let result = Triplet::from_bytes(&bytes);
        assert_eq!(result.tag, 0xa2);
        assert_eq!(result.length, 0xae as usize);
        assert_eq!(result.value, bytes[3..]);
        assert_eq!(result.len(), 177);
        assert_eq!(result.extended_length, 1);
    }
}