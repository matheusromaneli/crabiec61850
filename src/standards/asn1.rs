use byteorder::{BigEndian, ByteOrder};

pub struct Triplet {
    pub extended_length: u8,
    pub tag: u8,
    pub length: usize,
    pub value: Vec<u8>,
}

impl Triplet {
    fn extract_length(length: u8, bytes: &[u8]) -> usize {
        if length < 0x81 {
            length as usize
        } else if length < 0x82 {
            bytes[0] as usize
        } else if length < 0x83 {
            BigEndian::read_u16(bytes) as usize
        } else if length < 0x84 {
            BigEndian::read_u24(bytes) as usize
        } else if length < 0x85 {
            BigEndian::read_u32(bytes) as usize
        } else {
            panic!("ASN.1 length too long {}", length);
        }
    }

    pub fn length(&self) -> usize {
        2 + self.extended_length as usize + self.value.len()
    }

    pub fn byte_len(&self) -> usize {
        self.extended_length as usize + 2
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes: Vec<u8> = vec![];
        bytes.push(self.tag);
        if self.extended_length > 0 {
            bytes.push(self.extended_length | 0x80);
            let mut length_bytes = vec![0u8; self.extended_length as usize];
            match self.extended_length {
                1 => length_bytes[0] = self.length as u8,
                2 => BigEndian::write_u16(&mut length_bytes, self.length as u16),
                3 => BigEndian::write_u24(&mut length_bytes, self.length as u32),
                4 => BigEndian::write_u32(&mut length_bytes, self.length as u32),
                _ => panic!("ASN.1 length too long {}", self.length),
            }
            bytes.append(&mut length_bytes);
        } else {
            bytes.push(self.length as u8);
        }

        bytes.append(&mut self.value.clone());
        bytes
    }

    pub fn build(tag: u8, value: Vec<u8>) -> Triplet {
        let mut bytes: Vec<u8> = vec![];
        bytes.push(tag);
        let mut extended_length = 0;
        let length = value.len();
        match length {
            0..=0x7F => {}
            0x80..=0xFF => extended_length = 1,
            0x100..=0xFFFF => extended_length = 2,
            0x10000..=0xFFFFFF => extended_length = 3,
            0x1000000..=0xFFFFFFFF => extended_length = 4,
            _ => panic!("ASN.1 length too long {}", length),
        }
        if extended_length > 0 {
            bytes.push(extended_length | 0x80);
            let mut length_bytes = vec![0u8; extended_length as usize];
            match extended_length {
                1 => length_bytes[0] = length as u8,
                2 => BigEndian::write_u16(&mut length_bytes, length as u16),
                3 => BigEndian::write_u24(&mut length_bytes, length as u32),
                4 => BigEndian::write_u32(&mut length_bytes, length as u32),
                _ => panic!("ASN.1 length too long {}", length),
            }
            bytes.append(&mut length_bytes);
        } else {
            bytes.push(length as u8);
        }

        Triplet {
            extended_length,
            tag,
            length,
            value,
        }
    }

    pub fn from_bytes(bytes: &[u8]) -> Triplet {
        let tag = bytes[0];

        let extended_length: u8 = if bytes[1] > 0x80 {
            bytes[1] & 0x0F // 0x8X where X is the length
        } else {
            0u8
        };

        let length = Self::extract_length(bytes[1], &bytes[2..6]);
        let start_value = 2 + extended_length as usize;
        let value = bytes[start_value..start_value + length].to_vec();
        Triplet {
            extended_length,
            tag,
            length,
            value,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_bytes() {
        let bytes = vec![0x80, 0x04, 0x34, 0x30, 0x30, 0x30];
        let result = Triplet::from_bytes(&bytes);
        assert_eq!(result.tag, 0x80);
        assert_eq!(result.length, 4);
        assert_eq!(result.value, vec![0x34, 0x30, 0x30, 0x30]);
        assert_eq!(result.length(), 6);
        assert_eq!(result.extended_length, 0);
    }

    #[test]
    fn test_from_bytes_extended_length() {
        let bytes = vec![
            // seq_asdu field and extended length with 2 asdu
            0xa2, 0x81, 0xae, 0x30, 0x55, 0x80, 0x4, 0x34, 0x30, 0x30, 0x31, 0x82, 0x2, 0x12, 0xbf,
            0x83, 0x4, 0x0, 0x0, 0x0, 0x1, 0x85, 0x1, 0x2, 0x87, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x55, 0x80, 0x4, 0x34, 0x30, 0x30, 0x31,
            0x82, 0x2, 0x0, 0x0, 0x83, 0x4, 0x0, 0x0, 0x0, 0x1, 0x85, 0x1, 0x2, 0x87, 0x40, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        ];
        let result = Triplet::from_bytes(&bytes);
        assert_eq!(result.to_bytes(), bytes);
        assert_eq!(result.tag, 0xa2);
        assert_eq!(result.length, 0xae as usize);
        assert_eq!(result.value, bytes[3..]);
        assert_eq!(result.length(), 177);
        assert_eq!(result.extended_length, 1);
    }

    #[test]
    fn test_build_triplet() {
        let triplet = Triplet::build(0x80, vec![0x34, 0x30, 0x30, 0x30]);
        assert_eq!(triplet.tag, 0x80);
        assert_eq!(triplet.length, 4);
        assert_eq!(triplet.value, vec![0x34, 0x30, 0x30, 0x30]);
        assert_eq!(triplet.length(), 6);
        assert_eq!(triplet.extended_length, 0);
    }

    #[test]
    fn test_triplet_to_bytes() {
        let triplet = Triplet::build(0x80, vec![0x34, 0x30, 0x30, 0x30]);
        assert_eq!(triplet.to_bytes(), vec![0x80, 0x4, 0x34, 0x30, 0x30, 0x30]);
    }

    #[test]
    fn test_build_triplet_extended_length() {
        let bytes = vec![
            // seq_asdu field and extended length with 2 asdu
            0x30, 0x55, 0x80, 0x4, 0x34, 0x30, 0x30, 0x31, 0x82, 0x2, 0x12, 0xbf, 0x83, 0x4, 0x0,
            0x0, 0x0, 0x1, 0x85, 0x1, 0x2, 0x87, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x30, 0x55, 0x80, 0x4, 0x34, 0x30, 0x30, 0x31, 0x82, 0x2, 0x0, 0x0,
            0x83, 0x4, 0x0, 0x0, 0x0, 0x1, 0x85, 0x1, 0x2, 0x87, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        ];
        let triplet = Triplet::build(0xa2, bytes.clone());
        assert_eq!(triplet.tag, 0xa2);
        assert_eq!(triplet.length, 0xae as usize);
        assert_eq!(triplet.value, bytes);
        assert_eq!(triplet.length(), 177);
        assert_eq!(triplet.extended_length, 1);
    }
}
