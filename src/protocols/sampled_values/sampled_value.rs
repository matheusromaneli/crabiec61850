use crate::protocols::sampled_values::model::{Asdu, PDUTags, SampledValue};
use crate::standards::asn1::Triplet;
use byteorder::{BigEndian, ByteOrder};

impl SampledValue {
    pub fn from_bytes(bytes: &[u8]) -> SampledValue {
        let sav_pdu_triplet = Triplet::from_bytes(&bytes[8..]);
        let no_asdu_triplet = Triplet::from_bytes(&sav_pdu_triplet.value);
        let seq_asdu_triplet =
            Triplet::from_bytes(&sav_pdu_triplet.value[no_asdu_triplet.length()..]);

        let number_of_asdu = BigEndian::read_int(
            &no_asdu_triplet.value,
            1 + no_asdu_triplet.extended_length as usize,
        ) as u32;
        let mut asdus: Vec<Asdu> = vec![];
        let mut asdu_start = 0;
        for _ in 0..number_of_asdu {
            let asdu_triplet = Triplet::from_bytes(&seq_asdu_triplet.value[asdu_start..]);

            if asdu_triplet.tag != PDUTags::ASDU as u8 {
                panic!("ASDU tag is not 0x30 at offset {} of seq_asdu", asdu_start);
            }
            let asdu = Asdu::from_bytes(&asdu_triplet.value);
            asdus.push(asdu);
            asdu_start += asdu_triplet.length();
        }
        SampledValue {
            app_id: BigEndian::read_u16(&bytes[0..2]),
            length: BigEndian::read_u16(&bytes[2..4]),
            simulation: bytes[4] >> 3 == 1,
            reserved1: [bytes[4], bytes[5]],
            reserved2: [bytes[6], bytes[7]],
            number_of_asdu,
            asdu: asdus,
        }
    }

    fn pdu_to_bytes(&self) -> Vec<u8> {
        let mut bytes: Vec<u8> = vec![];

        let no_asdu_triplet =
            Triplet::build(PDUTags::NoAsdu as u8, vec![self.number_of_asdu as u8]);
        bytes.append(&mut no_asdu_triplet.to_bytes());

        let mut seq_asdu_bytes: Vec<u8> = vec![];
        for asdu in &self.asdu {
            let asdu_triplet = Triplet::build(PDUTags::ASDU as u8, asdu.to_bytes());
            seq_asdu_bytes.append(&mut asdu_triplet.to_bytes());
        }

        let seq_asdu_triplet = Triplet::build(PDUTags::SeqAsdu as u8, seq_asdu_bytes.clone());
        bytes.append(&mut seq_asdu_triplet.to_bytes());

        bytes
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes: Vec<u8> = vec![0; 4];
        BigEndian::write_u16(&mut bytes, self.app_id);
        BigEndian::write_u16(&mut bytes[2..], self.length);
        bytes.push(self.reserved1[0] | (self.simulation as u8) << 3);
        bytes.push(self.reserved1[1]);
        bytes.push(self.reserved2[0]);
        bytes.push(self.reserved2[1]);

        let pdu_triplet = Triplet::build(PDUTags::PDU as u8, Self::pdu_to_bytes(self));
        bytes.append(&mut pdu_triplet.to_bytes());

        bytes
    }

    pub fn next(&mut self) {
        for asdu in &mut self.asdu {
            asdu.next();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn decode_1_asdu() {
        let bytes: &[u8] = &[
            0x40, 0x02, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00, // Header
            0x60, 0x5c, // PDU
            0x80, 0x01, 0x01, // number of ASDU
            0xa2, 0x57, // sequence of ASDU
            0x30, 0x55, 0x80, 0x04, 0x34, 0x30, 0x30, 0x30, 0x82, 0x02, 0x00, 0x00, 0x83, 0x04,
            0x00, 0x00, 0x00, 0x01, 0x85, 0x01, 0x01, 0x87, 0x40, 0xff, 0xff, 0xff, 0xfd, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x20, 0x00, 0xff,
            0xff, 0xff, 0xfd, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfd, 0x00, 0x00, 0x00,
            0x00, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf6, 0x00,
            0x00, 0x20, 0x00, // ASDU
        ];

        let sampled_value = SampledValue::from_bytes(bytes);
        assert_eq!(0x4002, sampled_value.app_id);
        assert_eq!(102, sampled_value.length);
        assert_eq!(false, sampled_value.simulation);
        assert_eq!([0x00, 0x00], sampled_value.reserved1);
        assert_eq!([0x00, 0x00], sampled_value.reserved2);
        assert_eq!(1, sampled_value.number_of_asdu);
    }

    #[test]
    fn sv_to_bytes() {
        let bytes: &[u8] = &[
            0x40, 0x02, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00, // Header
            0x60, 0x5c, // PDU
            0x80, 0x01, 0x01, // number of ASDU
            0xa2, 0x57, // sequence of ASDU
            0x30, 0x55, 0x80, 0x04, 0x34, 0x30, 0x30, 0x30, 0x82, 0x02, 0x00, 0x00, 0x83, 0x04,
            0x00, 0x00, 0x00, 0x01, 0x85, 0x01, 0x01, 0x87, 0x40, 0xff, 0xff, 0xff, 0xfd, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x20, 0x00, 0xff,
            0xff, 0xff, 0xfd, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfd, 0x00, 0x00, 0x00,
            0x00, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf6, 0x00,
            0x00, 0x20, 0x00, // ASDU
        ];

        let sampled_value = SampledValue::from_bytes(bytes);
        assert_eq!(bytes, sampled_value.to_bytes());
    }

    #[test]
    fn sv_to_bytes_in_simulation() {
        let bytes: &[u8] = &[
            0x40, 0x02, 0x00, 0x66, 0x80, 0x00, 0x00, 0x00, // Header
            0x60, 0x5c, // PDU
            0x80, 0x01, 0x01, // number of ASDU
            0xa2, 0x57, // sequence of ASDU
            0x30, 0x55, 0x80, 0x04, 0x34, 0x30, 0x30, 0x30, 0x82, 0x02, 0x00, 0x00, 0x83, 0x04,
            0x00, 0x00, 0x00, 0x01, 0x85, 0x01, 0x01, 0x87, 0x40, 0xff, 0xff, 0xff, 0xfd, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x20, 0x00, 0xff,
            0xff, 0xff, 0xfd, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfd, 0x00, 0x00, 0x00,
            0x00, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf6, 0x00,
            0x00, 0x20, 0x00, // ASDU
        ];

        let sampled_value = SampledValue::from_bytes(bytes);
        assert_eq!(bytes, sampled_value.to_bytes());
    }

    #[test]
    fn sv_to_bytes_with_extended_length() {
        let bytes: &[u8] = &[
            0x40, 0x1, // SV ID
            0x0, 0xbf, // Length
            0x0, 0x0, 0x0, 0x0, // Reserved
            0x60, 0x81, 0xb4, // PDU
            0x80, 0x1, 0x2, // number of ASDU
            0xa2, 0x81, 0xae, // sequence of ASDU
            0x30, 0x55, 0x80, 0x4, 0x34, 0x30, 0x30, 0x31, 0x82, 0x2, 0x12, 0xbe, 0x83, 0x4, 0x0,
            0x0, 0x0, 0x1, 0x85, 0x1, 0x2, 0x87, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x30, 0x55, 0x80, 0x4, 0x34, 0x30, 0x30, 0x31, 0x82, 0x2, 0x12,
            0xbf, 0x83, 0x4, 0x0, 0x0, 0x0, 0x1, 0x85, 0x1, 0x2, 0x87, 0x40, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        ];

        let sampled_value = SampledValue::from_bytes(bytes);
        assert_eq!(bytes, sampled_value.to_bytes());
    }
}
